// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: protocols.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getProtocol = `-- name: GetProtocol :one
SELECT id, symbol, name, decimals, avatar, custodian_group_name, custodian_group_uid, tag, liquidity_model, capacity, daily_mint_limit, created_at, updated_at FROM protocols WHERE symbol = $1
`

func (q *Queries) GetProtocol(ctx context.Context, symbol string) (Protocol, error) {
	row := q.db.QueryRow(ctx, getProtocol, symbol)
	var i Protocol
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.Name,
		&i.Decimals,
		&i.Avatar,
		&i.CustodianGroupName,
		&i.CustodianGroupUid,
		&i.Tag,
		&i.LiquidityModel,
		&i.Capacity,
		&i.DailyMintLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProtocols = `-- name: GetProtocols :many
SELECT
    p.id, p.symbol, p.name, p.decimals, p.avatar, p.custodian_group_name, p.custodian_group_uid, p.tag, p.liquidity_model, p.capacity, p.daily_mint_limit, p.created_at, p.updated_at, 
    t.chain,
    t.chain_id,
    t.address
FROM protocols p
LEFT JOIN tokens t ON t.symbol = p.symbol
GROUP BY 
    p.id,
    p.symbol,
    p.name,
    p.custodian_group_name,
    p.custodian_group_uid,
    p.tag,
    p.decimals, 
    p.liquidity_model,
    p.avatar,
    p.capacity,
    p.daily_mint_limit,
    p.created_at,
    p.updated_at,
    t.chain,
    t.chain_id,
    t.address
`

type GetProtocolsRow struct {
	ID                 int64            `json:"id"`
	Symbol             string           `json:"symbol"`
	Name               string           `json:"name"`
	Decimals           int64            `json:"decimals"`
	Avatar             string           `json:"avatar"`
	CustodianGroupName string           `json:"custodian_group_name"`
	CustodianGroupUid  []byte           `json:"custodian_group_uid"`
	Tag                string           `json:"tag"`
	LiquidityModel     string           `json:"liquidity_model"`
	Capacity           pgtype.Numeric   `json:"capacity"`
	DailyMintLimit     pgtype.Numeric   `json:"daily_mint_limit"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
	Chain              pgtype.Text      `json:"chain"`
	ChainID            pgtype.Numeric   `json:"chain_id"`
	Address            []byte           `json:"address"`
}

func (q *Queries) GetProtocols(ctx context.Context) ([]GetProtocolsRow, error) {
	rows, err := q.db.Query(ctx, getProtocols)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProtocolsRow{}
	for rows.Next() {
		var i GetProtocolsRow
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Name,
			&i.Decimals,
			&i.Avatar,
			&i.CustodianGroupName,
			&i.CustodianGroupUid,
			&i.Tag,
			&i.LiquidityModel,
			&i.Capacity,
			&i.DailyMintLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Chain,
			&i.ChainID,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveProtocols = `-- name: SaveProtocols :exec
INSERT INTO protocols (symbol, name, custodian_group_name, custodian_group_uid, tag, liquidity_model, decimals, capacity, daily_mint_limit, avatar)
VALUES(unnest($1::text[]), unnest($2::text[]), unnest($3::text[]), unnest($4::bytea[]), unnest($5::text[]), unnest($6::text[]), unnest($7::bigint[]), unnest($8::numeric[]), unnest($9::numeric[]), unnest($10::text[])) ON CONFLICT DO NOTHING
`

type SaveProtocolsParams struct {
	Column1  []string         `json:"column_1"`
	Column2  []string         `json:"column_2"`
	Column3  []string         `json:"column_3"`
	Column4  [][]byte         `json:"column_4"`
	Column5  []string         `json:"column_5"`
	Column6  []string         `json:"column_6"`
	Column7  []int64          `json:"column_7"`
	Column8  []pgtype.Numeric `json:"column_8"`
	Column9  []pgtype.Numeric `json:"column_9"`
	Column10 []string         `json:"column_10"`
}

func (q *Queries) SaveProtocols(ctx context.Context, arg SaveProtocolsParams) error {
	_, err := q.db.Exec(ctx, saveProtocols,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
	)
	return err
}
