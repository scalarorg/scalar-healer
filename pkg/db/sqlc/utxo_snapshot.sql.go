// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: utxo_snapshot.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getUtxoSnapshot = `-- name: GetUtxoSnapshot :many
SELECT
    u.tx_id,
    u.vout,
    u.script_pubkey,
    u.amount_in_sats,
    u.custodian_group_uid,
    u.block_height,
    COALESCE(
      json_agg(
        CASE
          WHEN r.request_id IS NOT NULL THEN
            json_build_object('request_id', r.request_id, 'amount', ur.amount)
        END
      ) FILTER (WHERE r.request_id IS NOT NULL),
      '[]'
    ) AS reservations
  FROM utxos u
  LEFT JOIN utxo_reservations ur ON u.tx_id = ur.utxo_tx_id AND u.vout = ur.utxo_vout
  LEFT JOIN reservations r ON r.request_id = ur.reservation_id
  WHERE u.custodian_group_uid = $1::bytea
  GROUP BY u.tx_id, u.vout, u.script_pubkey, u.amount_in_sats, u.custodian_group_uid, u.block_height
  ORDER BY u.tx_id
`

type GetUtxoSnapshotRow struct {
	TxID              []byte         `json:"tx_id"`
	Vout              int64          `json:"vout"`
	ScriptPubkey      []byte         `json:"script_pubkey"`
	AmountInSats      pgtype.Numeric `json:"amount_in_sats"`
	CustodianGroupUid []byte         `json:"custodian_group_uid"`
	BlockHeight       int64          `json:"block_height"`
	Reservations      interface{}    `json:"reservations"`
}

func (q *Queries) GetUtxoSnapshot(ctx context.Context, dollar_1 []byte) ([]GetUtxoSnapshotRow, error) {
	rows, err := q.db.Query(ctx, getUtxoSnapshot, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUtxoSnapshotRow{}
	for rows.Next() {
		var i GetUtxoSnapshotRow
		if err := rows.Scan(
			&i.TxID,
			&i.Vout,
			&i.ScriptPubkey,
			&i.AmountInSats,
			&i.CustodianGroupUid,
			&i.BlockHeight,
			&i.Reservations,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
